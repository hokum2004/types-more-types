# Типы, больше типов!

## Введение

В процессе работы над кодом, при описании модели данных, приходится создавать новые типы, в первую очередь используя такие ключевые слова как `class`/`struct`/`record`. Это позволяет создавать новые типы данных, которые агрегируют в себе другие типы как простые, так и составные. Все это знают и применяют. Я же предлагаю взглянуть на случаи, когда моделируемая сущность, описывается существующим типом, таким как целое число или строка.

В статье я хочу поделиться мыслями, которые привели меня к использованию специальных типов там, где часто используются встроенные типы. На написание статьи побудил релиз и относительно массовый переход на третью версию языка Scala. В частности, я говорю о новой конструкции [`opaque type`][1], которая упростила создание новых типов. Но так же приведу примеры и других на языках с которыми довелось поработать, а именно Scala, C++, Go.

## Почти type alias, но лучше

Одним из плюсов использования новых типов является повышение читабельности кода, когда мы видно, что используется не просто какое-то целое число, а это временная метка как количество микросекунд прошедших с 1 января 1970 года. Или поля `user` и `goods` не просто строковые поля, а ID пользователя и ID товара. С этой задачей вполне справляются псевдонимы для типов. Правда используются они чаще для того, чтобы дать какое-то короткое имя в ограниченное области видимости для типа с длинным именем, или для фиксации определенных параметров шаблона/дженерика.

Примеры:

<spoiler title="Scala">

```scala
// определили типы
type Timestamp = Long
type UserId = String
type SKU = String

// используем
case class Sale(
    customer: UserId,
    item: SKU,
    date: Timestamp,
)
```

</spoiler>

<spoiler title="Go">

```go
// определили типы
type Timestamp = int64
type UserId = string
type SKU = string

// используем
type Sale struct {
    Customer UserId
    Item     SKU
    Date     Timestamp
}
```

</spoiler>

<spoiler title="C++">

```cpp
// определили типы
using Timestamp = int64_t;
using UserId = string;
using SKU = string;

// используем
struct Sale {
    UserId customer;
    SKU item;
    Timestamp date;
};
```

</spoiler>

Удобство чтения - это хорошо, но компилятор, увы, никак не подскажет в случае, если вместо `UserId` передали `SKU` и наоборот, или просто строку. Похоже и с `Timestamp` - можно `Timestamp`, можно любое другое целое. Применять можно, применяют, но хочется большего. Хочется, чтобы при передаче значения типа `SKU` или строкового типа туда, где ожидается `UserId` компилятор об этом сказал, выдал бы ошибку.

Собственно тут и пригодятся упомянутые `opaque types` (непрозрачные типы). Если с псевдонимамми типов примеры были плюс-минус одинаковые, то с созданием отдельных, самостоятельных типов различий будет куда больше. Под спойлерами будет как код так и описание.

Кажется, что такой "оверинжениринг" не нужен, но на практике я сталкивался с тем, что различные идентификаторы, которые были представлены строками в разных функциях передавались в разном порядке и когда функции используются рядом, то легко можно опечататься и передать не в том порядке. Тесты выловят такое, а может и нет, а компилятор сможет не допустить такое. Или добавляешь в начало или середину аргументов функции новый, ну вот по смыслу его логичнее в сердину добавить. Например, аргументы являются частями составного ключа и было бы не очень удобно, если часть ключа шла бы после значений. В таком случае специализированные типы опять же помогут и в коде вставить его в нужное место.

<spoiler title="Scala">

Как я сказал выше, тут и пригодятся `opaque type`. К объявлению псевдонима типа можно вначале дописать новое ключевое слово `opaque`. Это создаст новый тип, существовать он будет только во время компиляции, а в рантайме будет из себя представлять просто базовый тип. Таким образом никаких дополнительных затрат на него не будет, как при наследовании от `AnyVal`, где в определенных случаях обертка создавалась в рантайме.

Из нюансов, создать такой тип можно только из той области видимости где он был объявлен. Если прямо в пакете, то только из него, если внутри объекта, то только в теле или методах этого объекта. В связи с этим удобно создавать такой тип внутри вспомогательного объекта и добавлять метод `apply`. Чтобы уменьшить повторения, можно сделать вспомогательный трейт:

```scala
trait NewType[T]:
    opaque type Type = T
    def apply(v: T): Type = v
```

Тогда код из предыдущего примера будет выглядеть следующим образом:

```scala
// определили типы
object Timestamp extends NewType[Long]
type Timestamp = Timestamp.Type

object UserId extends NewType[String]
type UserId = UserId.Type

object SKU extends NewType[String]
type SKU = SKU.Type

// используем
case class Sale(
    customer: UserId,
    item: SKU,
    date: Timestamp,
)
```

И можно убедиться, что передать что-то другое туда где ожидаем новый тип нельзя.

```scala
trait NewType[T]:
    opaque type Type = T
    def apply(v: T): Type = v

object Timestamp extends NewType[Long]
type Timestamp = Timestamp.Type

type TimestampAlias = Long

def ExpectAlias(ts: TimestampAlias): String = "OK"

def ExpectNewType(ts: Timestamp): String = "OK"

val t1: TimestampAlias = 1000
val t2: Timestamp = Timestamp(1000)

ExpectAlias(t1) // <- OK
ExpectAlias(1000) // <- OK
ExpectNewType(t2) // <- OK
ExpectNewType(1000) // <- Ошибка компиляции
```

Использование вспомогательного трейта так же позволит добавить реализации необходимых given instances (реализации имплиситов в терминах новой скалы), которые будут выведены на базе given instances базовых типов.

</spoiler>

<spoiler title="Go">

С Go проще всего. Новый тип создается при помощи [type definition][2].

```go
// определили типы
type Timestamp int64
type UserId string
type SKU string

// используем
type Sale struct {
    Customer UserId
    Item     SKU
    Date     Timestamp
}
```

Отличие от варианта с псевдонимами в том, что при определении типа между именем нового типа и базовым типом нет знака равно. В целом, в Go создание новых типов можно встретить довольно часто, так как это позволяет "добавить" нужные методы к уже существующему типу, чтобы он начал соответствовать требуемому интерфейсу или просто обеспечить более удобную работу с ним.

```go
package main

type Timestamp int64

type TimestampAlias = int64

func ExpectAlias(v TimestampAlias) {}

func ExpectNewType(v Timestamp) {}

func main() {
	v := int64(1000)
	t1 := TimestampAlias(v)
	t2 := Timestamp(v)
	
	ExpectAlias(t1)   // <- OK
	ExpectAlias(v)    // <- OK
	
	ExpectNewType(t2) // <- OK
	ExpectNewType(v)  // <- Ошибка
}
```

Можно заметить, что во втором случае в `ExpectNewType` передается не просто число, а переменная с типом `int64`. Дело в том, что целочисленный литерал неявно приводится к любому типу который может быть сконструирован из него. Это целые числа, числа с плавающей точкой и типы для которых перечисленные являются базовыми (underlying). Поэтому вызов `ExpectNewType(1000)` не приведет к ошибке.

</spoiler>

<spoiler title="C++">

В C++ подобных языковых конструкций нет. Но можно создать шаблонную структуру с одним полем и в качестве аргумента шаблона использовать специальную структуру тег. Тег будет представлять собой пустую структуру с типом внутри, который будет использоваться в качестве базового типа.

```cpp
template <typename Tag>
struct NewType {
    explicit NewType(typename Tag::Type value): value(value) {}
    typename Tag::Type value;
};
```

И использование будет выглядеть так:

```cpp
struct TimestampTag {
    using Type = int64_t;
};
using Timestamp = NewType<TimestampTag>;

struct UserIdTag {
    using Type = std::string;
};
using UserId = NewType<UserIdTag>;

struct SKUTag {
    using Type = std::string;
};
using SKU = NewType<SKUTag>;

struct Sale {
    UserId customer;
    SKU item;
    Timestamp date;
};
```

```cpp
#include <string>

template <typename Tag>
struct NewType {
    using Raw = typename Tag::Type;
    explicit NewType(Raw const& value): value(value) {}
    explicit NewType(Raw && value): value(value) {}
    Raw value;
};

struct TimestampTag {
    using Type = int64_t;
};
using Timestamp = NewType<TimestampTag>;

using TimestampAlias = int64_t;

void ExpectAlias(TimestampAlias) {}

void ExpectNewType(Timestamp) {}

int main() {

    TimestampAlias ts1 = 1000;
    Timestamp ts2 = Timestamp(1000);

    ExpectAlias(ts1); // <- OK
    ExpectAlias(1000); // <- OK
    ExpectNewType(ts2); // <- OK
    ExpectNewType(1000); // <- Ошибка компиляции

    return 0;
}
```

</spoiler>

Уже использование таких типов, помогает улучшить читаемость кода и уменьшить ошибки вызванные передачей неправильных параметров. В момент написания нового кода вероятность подобных ошибок не очень большая, но она возрастет при расширении и рефакторинге кода. Хорошо, когда код покрыт тестами и подобные ошибки выловит разработчик до того изменения передадут в тестирование. Но ещё лучше, когда такие ошибки не пропустит компилятор.

Так же, введение нового типа позволит переопределить, например, способ конвертации в строку для вывода отладочной печати. Например, если информация о времени события хранится в Unix Time (число секунд прошедших с 1 января 1970), то смотреть в логи на числа вида `1682941151` не очень удобно. Гораздо проще понять в какой момент произошло событие, если в логе это значение будет представлено как '2023-05-01T11:39:11Z'. Введение отдельного типа повзолит это сделать. Другой пример - добавлять в лог к числу единицы измерения, чтобы было понятно о чем идет речь - градусы, радианы, метры, секунды, граммы или штуки.

Степень проработанности типов зависит от потребностей проекта. Где-то будет удобно переопределить и какие-то математические операторы, ввести функции для манипуляции такими типами, чтобы случайно не перемножить друг на дргу килограммы, например. В большинстве же случаев, достаточо просто будет определить новый тип и в случе каких-то манипуляций извлекать из него базовое значение. А бывает, что и вовсе нет нужды что-то делать кроме как писать/читать в/из хранилища данных.

## Можно ли лучше?

Всё выше перечисленное уже полезно само по себе. Но можно ли получить от типов еще больше пользы. Да, можно. Когда работаем с моделью данных, может потребоваться ввести ограничние на возможные значения. Например, если описывать трегуольник, то ограничением будет, что сумма длинн двух прилегающих сторон будет больше третьей оставшейся. В случае с одним значением подобные ограничения тоже могут быть. Например, географическая широта может быть ограничена значениями от -85° до 85°, а долгота от -180° до 180. Или от пользоватля (или внещней системы) ожидается строка только в определенном формате. Когда данные приходят в систему, то они проходят проверку и упомянутые ограничения, обычно, делаются на этапе валидации входных данных. Но дальше, смотря на описание структуры данных или сигнатуру функции эти ограничения теряются. И может возникнуть вопрос, а что делать если в какую-то функцию, которая работает с данными уже прошедшими валидацию, пришли невалидные данные. С одной строны - такая ситуация должна быть исключена, с другой при невалидных данных что-нибудь может сломаться или пойти не так.

Какие подходы есть к решению такой проблемы. Самое простое - ничего не делать, сичтаем, что данные которыми оперируют функции внутри сервиса валидны и ничего не сломается. Второй путь, вставить проверки, которые в случае ошибки кинут исключение, в языках такие проверки могут называться `assert` или `require`. Можно (нужно) к таким проверка добавить запись в лог, чтобы понимать что конкретно и где пошло не так и с какими данными. В случае C++ можно встретить, что такие проверки присутвсвуют в отладочной версии, но исключаются в релизной. Так приложение тестируется с ними и если что-то пошло не так на тестовом стенде, то приложение упадет, а после тестирования считаем, что всё хорошо и такие проверки не нужны и они убираются. Ещё, можно заморочиться и во всех функция добавить проверки и определить поведение в случае, если на вход пришли не валидные данные. Сложный и кропотливый враиант, который сложно поддерживать и в итоге, всё может свестить к предыдущему. А ещё, можно задать эти ограничения в самих типах. Как и в случае с треугольником, где проверка длин сторон может выполнятся в конструкторе типа треугольник или функции, которая его создает. C типами поверх существующих можно сдеkать такие же проверки. И тогда, там где эти типы используются можно не опасаться за валидность данных - данные не могут быть невалидными.

Как этого добиться - зависит от языка и в предыдущем разделе была заложена основа для добавления проверок, приступим.

<spoiler title="Scala">

</spoiler>

<spoiler title="Go">

Тут компилятор Go ничего предложить не может. Если хочется, чтобы при создании типа была обязательная валидация, то остается только написать в документации, чтобы тип создавался с использованием определенной функции и надеяться, что этому будут следовать.

Как вариант, можно сделать приватные типы и в функциях принимать их, но тогда использование таких типов будет ограничено одним пакетом. И всё равно остается некоторая возможность подставить неправильное значение, например передав константу из которой может быть сконструирован базовый тип. Но в целом, это будет работать, так как в основном валидации требуют данные приходящие из вне, которые будут представлены как переменные и автоматического приведения типов не будет.

В качестве примера, определим пакет `geo`:

```go
package geo

import (
	"fmt"
	"math"
)

type Metres float64
type Kilometres float64

type latitude float64
type longitude float64

type point struct {
	Lat latitude
	Lon longitude
}

type Point *point

func (m Metres) ToKilometres() Kilometres {
	return Kilometres(m / 1000)
}

func NewLat(v float64) (latitude, error) {
	if v < -85 || v > 85 {
		return 0, fmt.Errorf("latitude must be a value between -85 and 85, but got %v", v)
	}
	return latitude(v), nil
}

func NewLon(v float64) (longitude, error) {
	if v < -180 || v > 180 {
		return 0, fmt.Errorf("longitude must be a value between -180 and 180, but got %v", v)
	}
	return longitude(v), nil
}

func NewPoint(lat latitude, lon longitude) Point {
	return &point{
		Lat: lat,
		Lon: lon,
	}
}

// Distance returns the shortes distance, in metres, between two geo points.
func Distance(p1, p2 point) Metres {
    // compute distance ...
}
```

И для примера, будем получать координаты от пользователя и считать дистанцию между точками.

```go
package main

import (
	"example/geo"
	"fmt"
	"log"
)

func readPoint() (geo.Point, error) {
	var (
		rawLat float64
		rawLon float64
	)

	if _, err := fmt.Scanf("%f, %f", &rawLat, &rawLon); err != nil {
		return nil, err
	}

	lat, err := geo.NewLat(rawLat)
	if err != nil {
		return nil, nil
	}

	lon, err := geo.NewLon(rawLon)
	if err != nil {
		return nil, nil
	}

	return geo.NewPoint(lat, lon), nil
}

func main() {
	fmt.Print("Input start point (lat, lon): ")
	p1, err := readPoint()
	if err != nil {
		log.Fatalf("[E] reading the start point failed: %v", err)
		return
	}

	fmt.Print("Input end point (lat, lon): ")
	p2, err := readPoint()
	if err != nil {
		log.Fatalf("[E] reading the end point failed: %v", err)
		return
	}

	d := geo.Distance(*p1, *p2)

	fmt.Printf("Distance between points %v and %v is %.2f km\n", p1, p2, d.ToKilometres())
}
```

Тут видны недостатки того, что типы `geo.latitude`, `geo.longitude` и `geo.point` не экспортируются из пакета `geo`. Из вне, нельзя объявить функцию, которая бы создавала объект типа `geo.point`. Чтобы иметь возможность ссылаться на объекты такого типа, и понадобился тип `geo.Point`.

Почему нельзя экспортировать непосредственно `geo.point`? В данном случае, можно, так как значение по умолчанию для типа `float64` (ноль) для `geo.latitude` и `geo.longitude` являются валидными. Но если бы это было не так, то оставалась бы возможность создать невалидный объект, чего хочется избежать.

Пример исполнения программы:

```text
Input start point (lat, lon): 40.123, -73.456
Input end point (lat, lon): -30.456, 60.123
Distance between points &{40.123 -73.456} and &{-30.456 60.123} is 15718.03 km
```

</spoiler>

<spoiler title="C++">

</spoiler>


[1]: <https://docs.scala-lang.org/scala3/book/types-opaque-types.html> 'Scala: Opaque Types'
[2]: <https://go.dev/ref/spec#TypeDef> 'Go: Type Definitions'
[3]: <https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/time/Instant.html> 'Java: Instant'